# 十大经典排序算法解析

排序算法是程序员必备的基础知识，弄明白它们的原理和实现很有必要。

我们可以将常见的排序算法可以分成两类：

{% asset_img sort-category.png %}

**比较类排序**：通过比较来决定元素间的相对次序，时间复杂度为 $O(nlog_2n)～O(n^2)$

**非比较类排序**：不通过比较来决定元素间的相对次序，其时间复杂度可以突破  $O(nlog_2n)$，以线性时间运行。

它们的时间复杂度和空间复杂度如下表：

|           排序算法            | 时间复杂度（平均） | 时间复杂度（最坏） | 时间复杂度（最好） |  空间复杂度  | 稳定性 |
| :---------------------------: | :----------------: | :----------------: | :----------------: | :----------: | :----: |
|           插入排序            |      $O(n^2)$      |      $O(n^2)$      |       $O(n)$       |    $O(1)$    |  稳定  |
|           希尔排序            |    $O(n^{1.3})$    |      $O(n^2)$      |       $O(n)$       |    $O(1)$    | 不稳定 |
|         直接选择排序          |      $O(n^2)$      |      $O(n^2)$      |      $O(n^2)$      |    $O(1)$    | 不稳定 |
|            堆排序             |    $O(nlog_2n)$    |    $O(nlog_2n)$    |    $O(nlog_2n)$    |    $O(1)$    | 不稳定 |
| [冒泡排序](file://BubbleSort) |      $O(n^2)$      |      $O(n^2)$      |       $O(n)$       |    $O(1)$    |  稳定  |
|           快速排序            |    $O(nlog_2n)$    |      $O(n^2)$      |    $O(nlog_2n)$    | $O(nlog_2n)$ | 不稳定 |
|           归并排序            |    $O(nlog_2n)$    |    $O(nlog_2n)$    |    $O(nlog_2n)$    |    $O(n)$    |  稳定  |
|                               |                    |                    |                    |              |        |
|           计数排序            |      $O(n+k)$      |      $O(n+k)$      |      $O(n+k)$      |   $O(n+k)$   |  稳定  |
|            桶排序             |      $O(n+k)$      |      $O(n^2)$      |       $O(n)$       |   $O(n+k)$   |  稳定  |
|           基数排序            |      $O(n*k)$      |      $O(n*k)$      |      $O(n*k)$      |   $O(n+k)$   |  稳定  |

排序算法的**稳定性**是指，假设待排序序列中两元素相等，排序前后这两个相等元素的相对位置不变，则认为是稳定的。